module VerifyExamples.Compiler exposing (compileElm, compileMarkdown)

import Regex
import String
import String.Util exposing (capitalizeFirst, escape, indent, indentLines, unlines)
import VerifyExamples.Elm as Elm
import VerifyExamples.Function as Function exposing (Function)
import VerifyExamples.Markdown as Markdown
import VerifyExamples.ModuleName as ModuleName exposing (ModuleName)
import VerifyExamples.Test as Test exposing (Test)
import VerifyExamples.TestSuite as TestSuite exposing (TestSuite)


compileElm : Elm.CompileInfo -> TestSuite -> List ( ModuleName, String )
compileElm { moduleName } suite =
    compile
        moduleName
        { suite | imports = sourceImport moduleName :: suite.imports }


compileMarkdown : Markdown.CompileInfo -> TestSuite -> List ( ModuleName, String )
compileMarkdown { filePath } suite =
    compile
        (markdownModuleName filePath)
        suite


compile : ModuleName -> TestSuite -> List ( ModuleName, String )
compile moduleName suite =
    if TestSuite.notSpecial suite then
        [ compileTestPerModule moduleName suite ]
    else
        List.indexedMap (compileTestPerFunction moduleName suite) suite.tests


sourceImport : ModuleName -> String
sourceImport moduleName =
    "import " ++ ModuleName.toString moduleName ++ " exposing (..)"


markdownModuleName : String -> ModuleName
markdownModuleName filePath =
    filePath
        |> Regex.replace Regex.All (Regex.regex "\\.md$") (always "")
        |> String.split "/"
        |> List.map capitalizeFirst
        |> (::) "MARKDOWN"
        |> String.join "."
        |> ModuleName.fromString


compileTestPerModule : ModuleName -> TestSuite -> ( ModuleName, String )
compileTestPerModule moduleName suite =
    ( moduleName
    , unlines
        [ moduleHeader suite moduleName
        , imports suite
        , suite.tests
            |> List.indexedMap spec
            |> todoIfEmpty moduleName
        ]
    )


compileTestPerFunction : ModuleName -> TestSuite -> Int -> Test -> ( ModuleName, String )
compileTestPerFunction moduleName suite index test =
    let
        extendedModuleName =
            Test.specName index test
                |> ModuleName.extendName moduleName
    in
    ( extendedModuleName
    , unlines
        [ moduleHeader suite extendedModuleName
        , imports suite
        , unlines suite.types
        , ""
        , suite.helperFunctions
            |> List.map Function.toString
            |> unlines
        , ""
        , spec index test
        ]
    )


moduleHeader : TestSuite -> ModuleName -> String
moduleHeader { imports } moduleName =
    unlines
        [ "module VerifyExamples." ++ ModuleName.toString moduleName ++ " exposing (..)"
        , ""
        , "-- This file got generated by [elm-verify-examples](https://github.com/stoeffel/elm-verify-examples)."
        , "-- Please don't modify this file by hand!"
        , ""
        ]


imports : TestSuite -> String
imports { imports } =
    unlines
        [ "import Test"
        , "import Expect"
        , unlines imports
        , ""
        ]


spec : Int -> Test -> String
spec index test =
    unlines
        [ ""
        , ""
        , "spec" ++ toString index ++ " : Test.Test"
        , "spec" ++ toString index ++ " ="
        , indent 1 (testDefinition test)
        , indent 2 "\\() ->"
        , indent 3 "Expect.equal"
        , indentLines 4 (Test.specBody test)
        ]


todoIfEmpty : ModuleName -> List String -> String
todoIfEmpty moduleName tests =
    case tests of
        [] ->
            todo moduleName

        _ ->
            unlines tests


todo : ModuleName -> String
todo moduleName =
    unlines
        [ ""
        , ""
        , "spec : Test.Test"
        , "spec ="
        , indent 1 <|
            "Test.todo \"module "
                ++ ModuleName.toString moduleName
                ++ ": No examples to verify yet!\""
        ]


testDefinition : Test -> String
testDefinition test =
    String.concat
        [ "Test.test \""
        , Test.name test
        , ": \\n\\n"
        , Test.exampleDescription test
            |> String.lines
            |> List.map (indent 1 >> escape)
            |> String.join "\\n"
        , "\" <|"
        ]
